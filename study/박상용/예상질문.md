# **1. 공통 코드 모듈화 및 SDK/JAR 개발**

## **기본 질문**

1. 공통 코드 모듈화를 진행하게 된 배경과 목표는 무엇이었나요?
    1. 공통 코드가 JSP 파일인데, 3만줄이 넘어가면서 로직이 더 추가될 시 이슈가 되고 있었고, 이전 수정사항을 보려고 할 때도 코드가 너무 길어 컴퓨터에 부하가 걸리고 유지보수가 어려운 상태였습니다.
    이를 해결하기 위해 공통 로직을 쪼개고 기업별 커스텀 로직은 전략 패턴을 사용하여 모듈화하고 재사용성을 극대화하는 것이 목표였습니다.
    겸사겸사 SDK와 JAR 형태로 제공하면 서비스 간 종속성을 줄이고, 프레임워크 변경(마이그레이션)에도 유연하게 적용할 수 있도록 설계했습니다.
        - 전략 패턴이란 무엇인가요?
            
            전략 패턴은 동일한 작업을 수행하는 여러 알고리즘을 하나의 공통 인터페이스로 캡슐화하여, ,클라이언트가 런타임에 서로 다른 알고리즘을 선택해서 사용할 수 있도록 하는 패턴입니다. 이를 통해 클라이언트 코드와 알고리즘 구현부를 분리해서 유연성과 확장성을 높일 수 있습니다.
            
2. 모듈화를 진행하면서 가장 어려웠던 점과 이를 어떻게 해결했나요?
    1. 기존 코드에 기업별 커스텀 로직이 혼재되어 있고 공통 로직을 정확히 분리하는 작업이 까다로웠습니다.
        1. 코드 분석을 통해 중복으로 사용되며, 커스텀이 들어가는 부분에 대해 전략 패턴을 사용하여 공통 로직으로 두면서도 세부적인 구현은 다른 곳에서 할 수 있게 처리하였습니다.(로그인, 세션관리, 푸쉬 알림 등)
    2. 기업별 요구사항이 상이하고 SDK/JAR 도입 시 버전 관리 및 기능 확장을 공통적으로 관리해야 하는데 계약상 현장에서 바로 처리해줘야 하는 경우들도 많은 점이 어려웠습니다.
        1. 이 부분은 결국 해결하지 못하였습니다. 내부망에서의 작업만 가능하고 용량 문제로 java 파일을 안가져가는 경우도 많기 때문에 현장에서의 build도 어렵고, 동시에 여러 기업에서의 작업이 진행되는 경우도 많기 때문에 저도 납득 가능한 효율적인 방법이 생각나지 않아서 기존 방식으로 두게 되었습니다.
3. JSP 기반의 기존 코드에서 어떤 기준으로 공통 로직을 선별했나요?
    1. 어느 기업이더라도 기본적으로 가져가는 부분을 공통 로직으로 정했습니다. 예를 들어, 로그인, 세션관리, 푸쉬, 업무, 조직도에 대한 로직입니다.
    이 중 푸쉬의 경우 목적지만 달라져서 config로 해당 설정을 바꿀 수 있게 처리했었습니다.
4. SDK와 JAR을 개발하면서 가장 중점적으로 고려한 점은 무엇인가요?
    1. 기존 코드와의 호환성과 추후 진행할 마이그레이션 그리고 HTTP 상태 코드 및 에러 처리 표준화를 신경썼습니다.
5. Typescript SDK에서 module 방식과 CommonJS 방식을 모두 지원하도록 한 이유는 무엇인가요?
    1. 기존 코드에서 CJS 방식과 ESM 방식을 혼용하고 있었기 때문에 어떻게 보면 당연한 선택이었습니다. 그리고 이후 마이그레이션을 할 경우 저 개인적으론 ESM을 선호하지만, 기존 사용하는 라이브러리 중 CJS방식만 지원하는 경우도 있을 수 있고 기존 로직을 대체하기 쉬워지고 챗봇 연동, 위젯, 알림 등의 로직은 분리하여 호출 출처를 알 수 있게 하여 고객사에 제공할 수도 있겠다고 생각했기 때문에 모두 지원하도록 구현하였습니다.
        - ESM을 선호하는 이유
            
            ESM은 모듈 구조가 정적이어서 의존성을 파악하기 쉽습니다. 이로 인해 트리 쉐이킹 등의 최적화 기법을 적용하여 용량을 줄일 수도 있고, IDE에서도 사용부를 찾기가 쉽습니다.
            비동기 로딩 방식이기 때문에 페이지 렌더링이나 다른 작업이 동시에 진행될 수 있고 따라서 UI가 부드럽게 작동하거나 여러 모듈을 동시에 로드하여 전체 로드 시간을 단축할 수 있습니다.
            또한 표준화된 모듈 시스템으로 미래 지향적으로 봤을 때 앞으로 나올 최신의 소스들이 자연스럽게 지원할 수 있습니다.
            

## **심화 질문**

1. SDK 개발 시 HTTP 상태 코드 변환 및 에러 반환 처리를 어떻게 구현했나요?
    1. 가장 기본적인 200, 400, 401, 403 코드를 집중적으로 처리하였고, 에러가 났을 경우 message에 간단한 이유를 적어 에러메시지를 보고 조치할 영역을 쉽게 찾을 수 있도록 처리하였습니다.
2. 기존 세션 방식에서 JWT로 전환을 연구했다고 했는데, JWT 방식이 적용되면 어떤 이점과 단점이 발생할 수 있나요?
    1. 장점 : 서버에서 세션을 관리하지 않기 때문에 서버 부하가 줄어들고, 마이크로서비스에서 하나의 토큰으로 여러 서비스의 인증을 관리할 수 있습니다.
    2. 단점 : 토큰이 탈취되면 보안 이슈가 발생할 수 있고, 세션을 무효화해야 하는 상황이 생길 경우 블랙리스트 관리 등 기존 방식보다 어렵습니다.
    3. 이 때문에 refresh token rotation 방식을 고려했었습니다.
3. SDK/JAR 도입이 사내 정책 및 고객사 요구사항으로 인해 보류되었다고 했는데, 이를 극복할 방법이 있을까요?
    1. 현장에서의 급한 작업과 build가 문제이기 때문에 프레임워크를 아예 변경하여 nestJS 등으로 마이그레이션한다면 가능합니다. 물론 한번에 바꾸기는 어렵기 때문에 점진적으로 바꿔야 하겠지만, 바꾸면서 기업별 로직을 전략 패턴으로 바꾸어 각 기업의 코드에 영향이 없게 한다면 가능할 것 같습니다.
4. SDK의 상태 관리와 API 호출 최적화 방법에 대해 설명해주세요.
    1. 실제 운영중인 클라우드 서버에도 너무 많은 요청이 들어와 이슈로 이어지는 경우가 있었습니다. 그걸 참고한다면 일정 시간 내의 같은 조회 요청이라면 캐싱하는 방식과 처리량 제한 방식으로 처리할 것 같습니다. 처리량 제한 방식을 도입한다면 429 상태코드도 추가로 처리할 수 있을 것 같습니다.
5. 모듈화 과정에서 기업별 커스텀 로직을 분리하는 방식에 대해 설명해주세요.
    1. 먼저 간단 설정 및 목적지 변경의 경우라면 config 파일에 해당 설정을 분리하여 중복 코드를 줄이며 로직을 단순화하고, 기업별로 분리를 위해선 config 파일에 있는 기업 코드를 참고하여 각각을 전략 패턴으로 구현하면 공통 코드 부분을 단순하게 보이도록 줄일 수 있을 것 같습니다.

# **2. 세션 vs JWT 도입 검토 및 개선**

## **기본 질문**

1. 기존 세션 방식에서 어떤 문제가 있었나요?
2. 세션 클러스터링 방식과 JWT 방식의 차이점은 무엇인가요?
3. JWT의 stateless 특성이 세션 방식과 혼용될 경우 어떤 문제가 발생할 수 있나요?
4. 테스트 레포지토리를 운영하며 어떤 실험을 진행했나요?
5. 최종적으로 세션 클러스터링을 유지하는 것이 더 적합하다는 결론을 내린 이유는 무엇인가요?

## **심화 질문**

1. MSA 환경에서 세션과 JWT를 혼용할 경우 발생할 수 있는 보안 이슈는 무엇인가요?
2. JWT를 사용할 경우 세션 관리(로그아웃, 세션 만료 등)를 어떻게 처리할 수 있을까요?
3. JWT 방식에서 refresh token을 활용하는 방법과 보안적 고려 사항을 설명해주세요.
4. HTTP 상태 코드 처리 및 API 응답 표준화를 어떻게 설계했나요?
5. 세션과 JWT의 트레이드오프를 비교하며, 특정 상황에서 어떤 방식이 더 적합한지 설명해주세요.

# **3. 소켓 로직 개선 (ipt 소켓 & 상태 서버 소켓)**

## **기본 질문**

1. ipt 소켓에서 발생한 문제는 무엇이었나요?
2. 상태 서버 소켓의 동기화 문제를 어떻게 해결했나요?
3. 소켓 연결 상태를 관리하기 위해 Redis를 어떻게 활용했나요?
4. 실시간 로그인/자리비움/로그아웃 처리를 개선하는 과정에서 고려한 사항은 무엇인가요?
5. Electron 환경에서 부모·자식 창 간 소켓 처리 로직을 수정한 이유와 방법은 무엇인가요?

## **심화 질문**

1. 소켓 통신에서 연결 안정성을 확보하기 위해 어떤 방법을 적용했나요?
2. Redis를 활용한 소켓 상태 동기화 방식에서 race condition을 방지하는 방법은 무엇인가요?
3. WebSocket을 이용한 실시간 동기화에서 성능 최적화 방법을 설명해주세요.
4. 실시간 상태 동기화가 개선됨에 따라 어떤 측정 가능한 성과(VOC 감소, 시스템 안정성 향상 등)가 있었나요?
5. WebSocket 대신 다른 실시간 통신 방법(e.g., gRPC, SSE)을 선택할 가능성이 있었나요? 비교해 주세요.

# **4. 기업별 프로젝트 특이사항 게시글 작성**

## **기본 질문**

1. 기업별 프로젝트 특이사항 정리를 진행한 이유는 무엇인가요?
2. 게시글을 작성할 때 정형화된 템플릿을 어떻게 설계했나요?
3. 기존의 구두/개인 문서/기억에 의존하던 방식과 비교했을 때, 새로운 접근 방식의 장점은 무엇인가요?
4. 특이사항 게시글을 통해 커뮤니케이션 비용이 어떻게 절감되었나요?
5. 사내 여러 부서가 해당 문서를 활용하는 프로세스를 어떻게 확립했나요?

## **심화 질문**

1. 게시글을 작성하는 과정에서 발생한 주요 난관과 해결 방법을 설명해주세요.
2. 프로젝트 특이사항을 문서화할 때 가장 중요하게 생각한 원칙은 무엇인가요?
3. 문서화된 특이사항을 유지보수하는 방식은 어떻게 정했나요?
4. 이와 같은 접근 방식이 향후 사내 다른 프로젝트에도 적용될 수 있을까요?
5. 기존 정보들을 통합하는 과정에서 중복 데이터를 정리하는 기준은 무엇이었나요?

# **5. NestJS & NextJS 기반 JWT 마이그레이션**

## **기본 질문**

1. NestJS 및 NextJS 기반의 JWT 마이그레이션이 필요하게 된 이유는 무엇인가요?
2. 기존 PoC에서 학습한 내용을 마이그레이션 과정에 어떻게 활용했나요?
3. API 응답 표준화와 HTTP 상태 코드 정리를 어떻게 개선했나요?
4. JWT 인증을 NestJS 및 NextJS 환경에 적용하면서 발생한 주요 문제와 해결 방안을 설명해주세요.
5. 기존 SDK 코드를 어떻게 재활용했는지 설명해주세요.

## **심화 질문**

1. 마이그레이션 속도를 높이기 위해 어떤 전략을 활용했나요?
2. NestJS와 NextJS의 차이점과 각각의 장점을 어떻게 활용했나요?
3. JWT 인증 로직을 문서화하고 공유하는 과정에서 중요한 점은 무엇인가요?
4. JWT 기반 인증을 도입했을 때, 향후 서비스 확장성과 보안성에 미칠 영향은 무엇인가요?
5. 인증 방식의 표준화를 위해 고려한 요소는 무엇인가요?

# **추가 질문 (토스 핵심가치 연계)**

1. 토스의 **“목표 지향성과 빠른 실행”**이라는 가치와 연결 지어 본인의 프로젝트를 설명해 주세요.
2. **“투명한 지식 공유”** 관점에서 사내 문서화 및 SDK/JAR 개발이 어떤 영향을 미쳤다고 생각하나요?
3. **“사용자 중심(고객 가치 창출)”**을 고려했을 때, 진행한 프로젝트 중 가장 사용자에게 직접적인 영향을 준 사례는 무엇인가요?
4. **“지속적인 도전”**을 실천한 경험을 설명해 주세요.
5. 토스가 기술 선택을 할 때 고려해야 할 중요한 요소는 무엇이라고 생각하나요?
6. 원하는 계열사가 있다면 무엇이고, 그 이유가 무엇인가요?
